<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - BO2 Ranked</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        .admin-container {
            max-width: 800px;
            margin: 50px auto;
            padding: 30px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #FF6600;
            border-radius: 10px;
        }
        
        .admin-title {
            color: #FF6600;
            text-align: center;
            font-size: 2em;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #FF6600;
        }
        
        .admin-section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-left: 3px solid #00D4FF;
            border-radius: 5px;
        }
        
        .admin-section h3 {
            color: #00D4FF;
            margin-bottom: 15px;
        }
        
        .admin-btn {
            background: linear-gradient(135deg, #FF6600, #FF8833);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            margin: 10px 5px;
            transition: all 0.3s;
        }
        
        .admin-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 102, 0, 0.5);
        }
        
        .admin-btn.danger {
            background: linear-gradient(135deg, #dc3545, #c82333);
        }
        
        .admin-btn.danger:hover {
            box-shadow: 0 5px 20px rgba(220, 53, 69, 0.5);
        }
        
        .log-area {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        .log-area:empty::before {
            content: 'Aguardando opera√ß√£o...';
            color: #666;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: rgba(0, 212, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #00D4FF;
        }
        
        .stat-card .label {
            color: #aaa;
            font-size: 0.9em;
        }
        
        .stat-card .value {
            color: #FF6600;
            font-size: 2em;
            font-weight: bold;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="admin-container">
        <h1 class="admin-title">üõ†Ô∏è PAINEL DE ADMINISTRA√á√ÉO</h1>
        
        <div class="admin-section">
            <h3>üìä Estat√≠sticas do Sistema</h3>
            <div class="stats" id="stats">
                <div class="stat-card">
                    <div class="label">Total de Jogadores</div>
                    <div class="value" id="totalPlayers">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">Total de Partidas</div>
                    <div class="value" id="totalMatches">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">Pendentes</div>
                    <div class="value" id="totalPending">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">Duplicatas</div>
                    <div class="value" id="totalDuplicates">-</div>
                </div>
            </div>
            <button class="admin-btn" onclick="loadStats()">üîÑ Atualizar Estat√≠sticas</button>
        </div>
        
        <div class="admin-section">
            <h3>üßπ Limpeza de Duplicatas</h3>
            <p>Remove jogadores duplicados mantendo o documento com maior MMR ou mais antigo.</p>
            <button class="admin-btn danger" onclick="cleanupDuplicates()">üóëÔ∏è Limpar Duplicatas</button>
            <button class="admin-btn" onclick="listDuplicates()">üëÅÔ∏è Listar Duplicatas</button>
        </div>
        
        <div class="admin-section">
            <h3>üóÉÔ∏è Gerenciar Dados</h3>
            <button class="admin-btn" onclick="listAllPlayers()">üë• Listar Todos os Jogadores</button>
            <button class="admin-btn" onclick="listPendingMatches()">‚è≥ Listar Partidas Pendentes</button>
        </div>
        
        <div class="admin-section">
            <h3>‚ö†Ô∏è ZONA DE PERIGO</h3>
            <p style="color: #ff0; margin-bottom: 15px;">‚ö†Ô∏è Estas a√ß√µes s√£o IRREVERS√çVEIS e deletam dados permanentemente!</p>
            <button class="admin-btn danger" onclick="resetAllPlayerStats()">üîÑ Zerar Estat√≠sticas (Manter Contas)</button>
            <button class="admin-btn danger" onclick="deleteAllMatches()">üóëÔ∏è Deletar Todas as Partidas</button>
            <button class="admin-btn danger" onclick="deleteAllPending()">‚ùå Deletar Pendentes</button>
            <button class="admin-btn danger" onclick="nukeEverything()" style="background: linear-gradient(135deg, #8b0000, #ff0000);">‚ò¢Ô∏è DELETAR TUDO (NUCLEAR)</button>
        </div>
        
        <div class="admin-section">
            <h3>üìã Console de Logs</h3>
            <div class="log-area" id="logArea"></div>
            <button class="admin-btn" onclick="clearLogs()">üßΩ Limpar Logs</button>
        </div>
    </div>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    
    <script src="js/firebase-config.js"></script>
    
    <script>
        let auth, db;
        
        // Wait for Firebase
        window.addEventListener('load', async () => {
            await new Promise(resolve => {
                const check = setInterval(() => {
                    if (window.firebaseAuth && window.firebaseDB) {
                        clearInterval(check);
                        auth = window.firebaseAuth;
                        db = window.firebaseDB;
                        log('‚úÖ Conectado ao Firebase', 'success');
                        loadStats();
                        resolve();
                    }
                }, 100);
            });
        });
        
        function log(message, type = 'info') {
            const logArea = document.getElementById('logArea');
            const timestamp = new Date().toLocaleTimeString();
            const color = {
                'info': '#0ff',
                'success': '#0f0',
                'warning': '#ff0',
                'error': '#f00'
            }[type] || '#0ff';
            
            logArea.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            logArea.scrollTop = logArea.scrollHeight;
            console.log(message);
        }
        
        function clearLogs() {
            document.getElementById('logArea').innerHTML = '';
        }
        
        async function loadStats() {
            log('üìä Carregando estat√≠sticas...');
            
            try {
                // Total de jogadores
                const playersSnapshot = await db.collection('players').get();
                document.getElementById('totalPlayers').textContent = playersSnapshot.size;
                
                // Total de partidas
                const matchesSnapshot = await db.collection('matches').get();
                document.getElementById('totalMatches').textContent = matchesSnapshot.size;
                
                // Pendentes
                const pendingSnapshot = await db.collection('pendingConfirmations').get();
                document.getElementById('totalPending').textContent = pendingSnapshot.size;
                
                // Contar duplicatas
                const playersByUsername = {};
                playersSnapshot.forEach(doc => {
                    const username = doc.data().username;
                    if (!playersByUsername[username]) {
                        playersByUsername[username] = [];
                    }
                    playersByUsername[username].push(doc);
                });
                
                let duplicates = 0;
                for (const [username, docs] of Object.entries(playersByUsername)) {
                    if (docs.length > 1) duplicates++;
                }
                
                document.getElementById('totalDuplicates').textContent = duplicates;
                
                log(`‚úÖ Estat√≠sticas carregadas: ${playersSnapshot.size} jogadores, ${duplicates} duplicatas`, 'success');
            } catch (error) {
                log(`‚ùå Erro ao carregar estat√≠sticas: ${error.message}`, 'error');
            }
        }
        
        async function listDuplicates() {
            log('üîç Buscando duplicatas...');
            
            try {
                const snapshot = await db.collection('players').get();
                const playersByUsername = {};
                
                snapshot.forEach(doc => {
                    const username = doc.data().username;
                    if (!playersByUsername[username]) {
                        playersByUsername[username] = [];
                    }
                    playersByUsername[username].push({
                        id: doc.id,
                        data: doc.data()
                    });
                });
                
                let found = 0;
                for (const [username, docs] of Object.entries(playersByUsername)) {
                    if (docs.length > 1) {
                        found++;
                        log(`‚ö†Ô∏è ${username}: ${docs.length} documentos`, 'warning');
                        docs.forEach(doc => {
                            log(`   - ID: ${doc.id} | MMR: ${doc.data.mmr || 'N/A'} | Criado: ${new Date(doc.data.createdAt).toLocaleString()}`, 'info');
                        });
                    }
                }
                
                if (found === 0) {
                    log('‚ú® Nenhuma duplicata encontrada!', 'success');
                } else {
                    log(`üìä Total: ${found} usernames com duplicatas`, 'warning');
                }
            } catch (error) {
                log(`‚ùå Erro: ${error.message}`, 'error');
            }
        }
        
        async function cleanupDuplicates() {
            if (!confirm('‚ö†Ô∏è Tem certeza que deseja remover as duplicatas? Esta a√ß√£o n√£o pode ser desfeita!')) {
                return;
            }
            
            log('üßπ Iniciando limpeza de duplicatas...');
            
            try {
                const snapshot = await db.collection('players').get();
                log(`üìä Total de documentos: ${snapshot.size}`);
                
                const players = [];
                snapshot.forEach(doc => {
                    players.push({
                        id: doc.id,
                        data: doc.data()
                    });
                });
                
                // Agrupar por username
                const playersByUsername = {};
                players.forEach(player => {
                    const username = player.data.username;
                    if (!playersByUsername[username]) {
                        playersByUsername[username] = [];
                    }
                    playersByUsername[username].push(player);
                });
                
                let duplicatesFound = 0;
                let documentsToDelete = [];
                
                for (const [username, docs] of Object.entries(playersByUsername)) {
                    if (docs.length > 1) {
                        log(`‚ö†Ô∏è Duplicata: ${username} (${docs.length} docs)`, 'warning');
                        duplicatesFound++;
                        
                        // Ordenar por MMR (maior primeiro) ou data (mais antigo)
                        docs.sort((a, b) => {
                            const mmrA = a.data.mmr || 0;
                            const mmrB = b.data.mmr || 0;
                            if (mmrA !== mmrB) return mmrB - mmrA;
                            return (a.data.createdAt || 0) - (b.data.createdAt || 0);
                        });
                        
                        const toKeep = docs[0];
                        const toDelete = docs.slice(1);
                        
                        log(`  ‚úÖ Mantendo: ${toKeep.id} (MMR: ${toKeep.data.mmr})`, 'success');
                        toDelete.forEach(doc => {
                            log(`  ‚ùå Deletando: ${doc.id} (MMR: ${doc.data.mmr})`, 'error');
                            documentsToDelete.push(doc.id);
                        });
                    }
                }
                
                if (documentsToDelete.length === 0) {
                    log('‚ú® Nenhuma duplicata encontrada!', 'success');
                    return;
                }
                
                log(`üóëÔ∏è Deletando ${documentsToDelete.length} documentos...`, 'warning');
                
                // Deletar em lote
                const batch = db.batch();
                documentsToDelete.forEach(docId => {
                    batch.delete(db.collection('players').doc(docId));
                });
                
                await batch.commit();
                
                log(`‚úÖ Limpeza conclu√≠da!`, 'success');
                log(`‚úÖ ${duplicatesFound} usernames tinham duplicatas`, 'success');
                log(`‚úÖ ${documentsToDelete.length} documentos deletados`, 'success');
                
                // Atualizar estat√≠sticas
                await loadStats();
                
                alert('‚úÖ Limpeza conclu√≠da com sucesso!');
                
            } catch (error) {
                log(`‚ùå Erro durante limpeza: ${error.message}`, 'error');
                alert('‚ùå Erro: ' + error.message);
            }
        }
        
        async function listAllPlayers() {
            log('üë• Listando todos os jogadores...');
            
            try {
                const snapshot = await db.collection('players').get();
                log(`üìä Total: ${snapshot.size} jogadores`);
                
                const players = [];
                snapshot.forEach(doc => {
                    players.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                
                // Ordenar por MMR
                players.sort((a, b) => (b.mmr || 0) - (a.mmr || 0));
                
                players.forEach((player, index) => {
                    log(`${index + 1}. ${player.username} | MMR: ${player.mmr || 'N/A'} | V/D: ${player.wins || 0}/${player.losses || 0}`, 'info');
                });
                
            } catch (error) {
                log(`‚ùå Erro: ${error.message}`, 'error');
            }
        }
        
        async function listPendingMatches() {
            log('‚è≥ Listando partidas pendentes...');
            
            try {
                const snapshot = await db.collection('pendingConfirmations').get();
                log(`üìä Total: ${snapshot.size} pendentes`);
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    log(`${data.winner} vs ${data.loser} | Reportado por: ${data.reporter}`, 'info');
                });
                
                if (snapshot.size === 0) {
                    log('‚ú® Nenhuma partida pendente!', 'success');
                }
                
            } catch (error) {
                log(`‚ùå Erro: ${error.message}`, 'error');
            }
        }
        
        // ============ ZONA DE PERIGO ============
        
        async function resetAllPlayerStats() {
            const confirmed = confirm('‚ö†Ô∏è ATEN√á√ÉO! Esta a√ß√£o ir√° ZERAR todas as estat√≠sticas de TODOS os jogadores (MMR, vit√≥rias, derrotas, K/D, etc).\n\nAs contas (login/senha) ser√£o mantidas.\n\nDeseja continuar?');
            if (!confirmed) return;
            
            const doubleCheck = prompt('Digite "ZERAR TUDO" para confirmar:');
            if (doubleCheck !== 'ZERAR TUDO') {
                log('‚ùå A√ß√£o cancelada', 'warning');
                return;
            }
            
            log('üîÑ Zerando estat√≠sticas de todos os jogadores...');
            
            try {
                const snapshot = await db.collection('players').get();
                log(`üìä Encontrados ${snapshot.size} jogadores`);
                
                const batch = db.batch();
                let count = 0;
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const resetData = {
                        ...data,
                        mmr: 1000,
                        rank: 'Prata III',
                        wins: 0,
                        losses: 0,
                        totalKills: 0,
                        totalDeaths: 0,
                        winStreak: 0,
                        bestStreak: 0,
                        gamesPlayed: 0,
                        achievements: [],
                        seasonStats: {
                            1: {
                                wins: 0,
                                losses: 0,
                                mmr: 1000
                            }
                        }
                    };
                    
                    batch.set(doc.ref, resetData);
                    count++;
                    log(`  ‚úÖ ${data.username} resetado`, 'success');
                });
                
                await batch.commit();
                
                log(`‚úÖ ${count} jogadores resetados com sucesso!`, 'success');
                await loadStats();
                alert('‚úÖ Estat√≠sticas resetadas com sucesso!');
                
            } catch (error) {
                log(`‚ùå Erro: ${error.message}`, 'error');
                alert('‚ùå Erro ao resetar: ' + error.message);
            }
        }
        
        async function deleteAllMatches() {
            const confirmed = confirm('‚ö†Ô∏è ATEN√á√ÉO! Esta a√ß√£o ir√° DELETAR TODAS as partidas do hist√≥rico.\n\nEsta a√ß√£o N√ÉO pode ser desfeita!\n\nDeseja continuar?');
            if (!confirmed) return;
            
            log('üóëÔ∏è Deletando todas as partidas...');
            
            try {
                const snapshot = await db.collection('matches').get();
                log(`üìä Encontradas ${snapshot.size} partidas`);
                
                const batch = db.batch();
                snapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });
                
                await batch.commit();
                
                log(`‚úÖ ${snapshot.size} partidas deletadas!`, 'success');
                await loadStats();
                alert('‚úÖ Partidas deletadas com sucesso!');
                
            } catch (error) {
                log(`‚ùå Erro: ${error.message}`, 'error');
            }
        }
        
        async function deleteAllPending() {
            const confirmed = confirm('‚ö†Ô∏è Deletar todas as confirma√ß√µes pendentes?');
            if (!confirmed) return;
            
            log('üóëÔ∏è Deletando confirma√ß√µes pendentes...');
            
            try {
                const snapshot = await db.collection('pendingConfirmations').get();
                log(`üìä Encontradas ${snapshot.size} pendentes`);
                
                const batch = db.batch();
                snapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });
                
                await batch.commit();
                
                log(`‚úÖ ${snapshot.size} pendentes deletadas!`, 'success');
                await loadStats();
                alert('‚úÖ Pendentes deletadas com sucesso!');
                
            } catch (error) {
                log(`‚ùå Erro: ${error.message}`, 'error');
            }
        }
        
        async function nukeEverything() {
            const confirmed = confirm('‚ò¢Ô∏è ATEN√á√ÉO M√ÅXIMA! ‚ò¢Ô∏è\n\nEsta a√ß√£o ir√° DELETAR:\n- TODOS os jogadores\n- TODAS as partidas\n- TODAS as confirma√ß√µes pendentes\n\nO SISTEMA SER√Å COMPLETAMENTE LIMPO!\n\nEsta a√ß√£o N√ÉO PODE SER DESFEITA!\n\nTem ABSOLUTA CERTEZA?');
            if (!confirmed) return;
            
            const doubleCheck = prompt('Digite "DESTRUIR TUDO" para confirmar a destrui√ß√£o total:');
            if (doubleCheck !== 'DESTRUIR TUDO') {
                log('‚ùå A√ß√£o cancelada', 'warning');
                return;
            }
            
            const tripleCheck = confirm('√öLTIMA CONFIRMA√á√ÉO: Deletar TUDO permanentemente?');
            if (!tripleCheck) return;
            
            log('‚ò¢Ô∏è INICIANDO DESTRUI√á√ÉO NUCLEAR...', 'error');
            
            try {
                // Deletar jogadores
                log('üóëÔ∏è Deletando jogadores...');
                const playersSnapshot = await db.collection('players').get();
                const playersBatch = db.batch();
                playersSnapshot.forEach(doc => playersBatch.delete(doc.ref));
                await playersBatch.commit();
                log(`‚úÖ ${playersSnapshot.size} jogadores deletados`, 'success');
                
                // Deletar partidas
                log('üóëÔ∏è Deletando partidas...');
                const matchesSnapshot = await db.collection('matches').get();
                const matchesBatch = db.batch();
                matchesSnapshot.forEach(doc => matchesBatch.delete(doc.ref));
                await matchesBatch.commit();
                log(`‚úÖ ${matchesSnapshot.size} partidas deletadas`, 'success');
                
                // Deletar pendentes
                log('üóëÔ∏è Deletando pendentes...');
                const pendingSnapshot = await db.collection('pendingConfirmations').get();
                const pendingBatch = db.batch();
                pendingSnapshot.forEach(doc => pendingBatch.delete(doc.ref));
                await pendingBatch.commit();
                log(`‚úÖ ${pendingSnapshot.size} pendentes deletadas`, 'success');
                
                log('‚ò¢Ô∏è DESTRUI√á√ÉO NUCLEAR COMPLETA!', 'error');
                await loadStats();
                alert('‚ò¢Ô∏è Sistema completamente limpo! Todos os dados foram deletados.');
                
            } catch (error) {
                log(`‚ùå Erro durante destrui√ß√£o: ${error.message}`, 'error');
                alert('‚ùå Erro: ' + error.message);
            }
        }
    </script>
</body>
</html>
